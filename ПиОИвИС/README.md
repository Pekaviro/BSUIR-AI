# Лабораторная работа №1

## Цель работы
Исследовать свойства структур данных и разработать библиотеку алгоритмов обработки структур данных.

## Задача
Разработать библиотеку для работы со структурой данных и систему тестов, которые продемонстрировали бы работоспособность реализованной библиотеки.

#### Вариант индивидуального задания №13
Красно-черное дерево. Вставка. Удаление. Поиск. Поиск минимума,максимума, ближайшего большего и ближайшего меньшего.

## Определения
**Красно-черное дерево** представляет собой бинарное дерево поиска с одним дополнительным битом цвета в каждом узле
**Черная высота** - количество черных узлов на пути от узла x(не считая сам узел) к листу.

### Свойства красно-черного дерева
Бинарное дерево поиска является красно-черным, если оно удовлетворяет следующим красно-черным свойствам:
1. Каждый узел дерева является красным или чёрным.
2. Корень дерева является черным.
3. Каждый лист дерева является черным.
4. Если узел - красный, то оба его дочерних узла - черные.
5. Для каждого узла все пути от него до листьев, являющихся его потомками, содержат одно и то же количество черных узлов.

## Функции библиотеки

1. Добавление узла.
Функция `void InsertNode(Node*& root, int value)`:
	* Принимает аргументы root - корень дерева и value - значение вставляемой вершины.
	* Проводит поиск подходящего для вставки места в дереве.
	* Создаёт новую ***красную*** вершину.
	* Вызывает функцию `InsertFix`.
	* !Если вершина с таким значением уже есть в дереве, функция возвращает соответствующее сообщение.
	
2. Отладка дерева для соблюдения всех красно-черных свойств.
Функция `InsertFix(Node* node, Node*& root)`:
	* Принимает аргументы root - корень дерева и node - указатель на вершину.
	* Производит повороты дерева и перекраску узлов для сохранения красно-черных свойств дерева после вставки новой вершины.

3. Удаление узла с определенным значением.
Функция `void DeleteNode(Node*& root, int value)`:
	* Принимает аргументы root - корень дерева и value - значение удаляемой вершины.
	* Проводит поиск заданной вершины по ключу.
	* Вызывает функцию `Delete`.
	
4. Удаление вершины и отладка дерева для соблюдения красно-черных свойств.
Функция `void Delete(Node*& root, Node* node)`
	* Принимает аргументы root - корень дерева и node - указатель на вершину.
	* Производит повороты дерева и перекраску узлов для сохранения красно-черных свойств дерева после вставки новой вершины.
	* Вызывает функцию `СlearNode`.
	
5. Непосредственное удаление вершины.
Функция `void ClearNode(Node* node)`
	* Принимает аргумент node - указатель на вершину.
	* Удаляет необходимую вершину.
	* Очищает память, занимаемую удаленной вершиной.
	
6. Вывод информации обо всём дереве на экран.
Функция `void Print(Node* root)`
	* Принимает аргумент root - корень дерева.
	* Выводит в консоль информацию о каждом узле дерева: значение, цвет и родителя.

7. Левый поворот.
Функция `void LeftRotate(Node*& root, int value)`
	* Принимает аргументы root - корень дерева и value - значение вставляемой вершины.
	* Осуществляет левый поворот вокруг вершины с ключом `key`.


8. Правый поворот.
Функция `void RightRotate(Node*& root, int value)`
	* Принимает аргументы root - корень дерева и value - значение вставляемой вершины.
	* Осуществляет правый поворот вокруг вершины с ключом `key`. 

9. Функция поиска вершины в заданном дереве, с заданным значением.
Функция `Node* Find(Node* root, int value)`
	* Принимает аргументы root - корень дерева и value - значение искомой вершины.
	* Возвращает указатель на вершину с заданным значением.
	* !Если вершины с таким значением нет в дереве, функция возвращает соответствующее сообщение.

10. Поиск узла с максимальным значением в дереве.
Функция `int FindMax(Node* root)`
	* Принимает аргумент root - корень дерева.
	* Находит самый правый узел.
	* Возвращает указатель на вершину с максимальным значением.

11. Поиск узла с минимальным значением в дереве.
Функция `int FindMin(Node* root)`
	* Принимает аргумент root - корень дерева.
	* Находит самый левый узел.
	* Возвращает указатель на вершину с минимальным значением.

12. Функция поиска ближайшего большего.
Функция `int FindNearestMax(Node* root, int value)`
	* Принимает аргументы root - корень дерева и value - значение искомой вершины.
	* Возвращает значение искомой вершины.
	* !Если вершины со значением value нет в дереве, функция возвращает соответствующее сообщение.
	* !Если заданная вершина является максимальной, функция возвращает соответствующее сообщение.

13. Функция поиска ближайшего меньшего.
Функция `int FindNearestMin(Node* root, int value)`
	* Принимает аргументы root - корень дерева и value - значение искомой вершины.
	* Возвращает значение искомой вершины.
	* !Если вершины со значением value нет в дереве, функция возвращает соответствующее сообщение.
	* !Если заданная вершина является минимальной, функция возвращает соответствующее сообщение.

## Тестирование библиотеки
Для тестирования будем сравнивать результат, который выдаёт программа, и полученный собственными вычислениями.

##### 1-й тест
В случае вставки первой некорневой вершины, она всегда остаётся красной.
```c++
InsertNode(root, 17);	
assert(Find(root, 17)->Red);

cout << "Первый тест пройден успешно.\n";
```

![1test](https://github.com/iis-32170x/RPIIS/blob/%D0%9F%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%BE%D0%B2%D0%B0_%D0%92/sem2/images/1test.png)

##### 2-й тест
В случае вставки таких вершин в таком порядке, вершина 17 перекрасится в чёрный.
```c++
InsertNode(root, 11);
InsertNode(root, 16); 
InsertNode(root, 20);
assert(!Find(root, 17)->Red);

cout << "Второй тест пройден успешно.\n";
```

![2test](https://github.com/iis-32170x/RPIIS/blob/%D0%9F%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%BE%D0%B2%D0%B0_%D0%92/sem2/images/2test.png)

##### 3-й тест
После вставки вершин с ключами 7 и 5, левым потомком корня дерева должен стать узел с ключом 7.
```c++
InsertNode(root, 7);
InsertNode(root, 5); 
assert(root->left->value == 7);

cout << "Третий тест пройден успешно.\n";
```

![3test](https://github.com/iis-32170x/RPIIS/blob/%D0%9F%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%BE%D0%B2%D0%B0_%D0%92/sem2/images/3test.png)

##### 4-й тест
После вставки узла с ключом 12, левый потомок от корня должен перекраситься в красный цвет.
```c++
InsertNode(root, 12); 
assert(root->left->Red = 1);

cout << "Четвёртый тест пройден успешно.\n";
```

![4test](https://github.com/iis-32170x/RPIIS/blob/%D0%9F%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%BE%D0%B2%D0%B0_%D0%92/sem2/images/4test.png)

##### 5-й тест
Поиск максимального элемента в дереве, в нашем случае это - 20.
```c++
assert(FindMax(root) == 20); 
cout << "Пятый тест пройден успешно.\n";
```

##### 6-й тест
Поиск минимального элемента в дереве, в нашем случае это - 5.
```c++
assert(FindMin(root) == 5); 
cout << "Шестой тест пройден успешно.\n";
```

##### 7-й тест
Поиск ближайшего меньшего элемента для вершины 13. Этим элементом будет 12.
```c++
assert(FindNearestMin(root, 13) == 12); 
cout << "Седьмой тест пройден успешно.\n";
```

##### 8-й тест
Поиск ближайшего большего элемента для вершины 20. Этот элемент сам максимальный.
```c++
FindNearestMax(root, 20);
cout << "Восьмой тест пройден успешно.\n";
```

##### 9-й тест
Поиск несуществующей вершины в дереве.
```c++
assert(Find(root, 23) == nullptr); 
cout << "Девятый тест пройден успешно.\n";
```

##### 10-й тест
Вывод информации обо всём дереве на экран.
```c++
Print(root);
cout << "Десятый тест пройден успешно.\n";
```

Результат выполнения программы для тестирования:

![result](https://github.com/iis-32170x/RPIIS/blob/%D0%9F%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%BE%D0%B2%D0%B0_%D0%92/sem2/images/result.png)

## Выводы
Во время выполнения лабораторной работы я исследовала свойства структур данных, разработала библиотеку функций обработки структур данных и программу для тестирования реальзованной библиотеки. Также я ознакомилась с таким понятием как красно-черные деревья и с их свойствами.

## Источники
1. Алгоритмы: построение и анализ, 2-е издание. : Пер. с англ. – М. :
Издательский дом «Вильямс», 2005. – 1296 с.

2. https://github.com/iis-32170x/RPIIS/blob/017a7f06ed1c466f96d403985db294e5d178487c/sem2/lab1/rbtree.cpp)))))