# Расчётная работа

### Цель

Получить навыки формализации и обработки информации с использованием семантических сетей.

### Задание

Реализовать код на языке `С++`, который, используя в качестве способа выражения графа матрицу инцидентности, будет находить минимальный простой разрез неориентированного графа.

### Ключевые понятия

`Граф`(абсолютное понятие) — математическая абстракция реальной системы любой природы, объекты которой обладают парными связями.

![граф](/sem2/images/Graph.png)

`Неориентированный граф`(абсолютное понятие) - граф, в которых все ребра являются звеньями, то есть порядок двух концов ребра графа не существенен.

![неориентированный граф](/sem2/images/NotOriented.png)

`Разрез графа`(относительное понятие) — это разбиение вершин графа на два непустых непересекающихся подмножества.

![разрез](/sem2/images/razrez.png)

`Минимальный разрез графа`(относительное понятие) — разрез, при котором размер или вес разреза не превышает размер любого другого разреза. Для невзвешенного графика минимальным разрезом будет просто разрез с наименьшим количеством ребер. Для взвешенного графика сумма весов всех ребер на разрезе определяет, является ли это минимальным разрезом. 

![минимальный разрез](/sem2/images/min_razrez.png)

## Алгоритм выполнения задания

1. Создаём множество непосещённых вершин.

2. Создаём счетчик минимального разреза min_cut=∞.

3. Создаём множество вершин А, куда последовательно будут добавляться вершины с большим весом.

4. Создаём счётчик n-1 фаз, где n - количество вершин в графе.

5. Добавляем произвольную вершину в множество А

6. Из смежных вершин к множеству А, добавляем в множество вершину с большим весом. 

	6.1. Повторяем процесс до n-1 фазы (включая предпоследнюю вершину(s))

7. Если вес последней недобавленной вершины(t) меньше записанного минимального разреза в minR, то перезаписываем его в minR.

8. Сливаем две последние вершины в одну.

9. Очищаем множество А

10. Если n = 1 (в графе осталась одна вершина), то выводим результат и завершаем алгоритм.

11. Если n не равно 1, то переходим к пункту 5.

## Выполнение алгоритма

Переменная `graph` получает в качестве значения sc-узел неориентированного взвешенного графа.

![1](/sem2/images/1.png)

Переменная `not_added_vertexes` получит в качестве значения множество недобавленных в множество вершин.

![2](/sem2/images/2.png)

Создаём счётчик `number_of_vertexes` равный 5.

![3](/sem2/images/3.png)

Добавляем переменную `min_cut` со значением ∞.

![4](/sem2/images/4.png)

Создание волны, включающей вершину 1v.

![5](/sem2/images/5.png)

Создание волны, включающей вершину 3v.

![6](/sem2/images/6.png)

Создание волны, включающей вершину 2v.

![7](/sem2/images/7.png)

Создание волны, включающей вершину 5v.

![8](/sem2/images/8.png)

Создание волны, включающей вершину 4v.

![9](/sem2/images/9.png)

В счётчик `_min_cut` записываем вес вершины 4v = 6, так как меньше бесконечности. Объединяем вершины 4v и 5v `_number_of_vertexes` уменьшаем на один. Удаляем множество посещённых вершин Создаём волну, включающуюю вершину 1v.

![10](/sem2/images/10.png)

Создание волны, включающей вершину 3v.

![11](/sem2/images/11.png)

Создание волны, включающей вершину 2v.

![12](/sem2/images/12.png)

Создание волны, включающей вершину 5v,4v.

![13](/sem2/images/13.png)

Объединяем вершины 2v и 4v,5v. `_number_of_vertexes` уменьшаем на один. Удаляем множество посещённых вершин. Создаём волну, включающуюю вершину 1v.

![14](/sem2/images/14.png)

Создание волны, включающей вершину 3v.

![15](/sem2/images/15.png)

Создание волны, включающей вершину 2v.

![16](/sem2/images/16.png)

Объединяем вершины 3v и 2v,4v,5v. `_number_of_vertexes` уменьшаем на один. Удаляем множество посещённых вершин. Создаём волну, включающуюю вершину 1v.

![17](/sem2/images/17.png)

Создание волны, включающей вершину 3v,2v,5v,4v

![18](/sem2/images/18.png)

Объединяем вершины 1v и 3v,2v,4v,5v. `_number_of_vertexes` уменьшаем на один. Удаляем множество посещённых вершин.

![19](/sem2/images/19.png)

Результат работы алгоритма

_min_cut = 6

## Тестирование 

#### Тест 1

Входные данные:

![граф1](/sem2/images/graph1.png)

Результат работы алгоритма:

_min_cut = 1

#### Тест 2

Входные данные:

![граф2](/sem2/images/graph2.png)

Результат работы алгоритма:

_min_cut = 2

#### Тест 3

Входные данные:

![граф3](/sem2/images/graph3.png)

Результат работы алгоритма:

_min_cut = 1

#### Тест 4

Входные данные:

![граф4](/sem2/images/graph4.png)

Результат работы алгоритма:

_min_cut = 4

#### Тест 5

Входные данные:

![граф5](/sem2/images/graph5.png)

Результат работы алгоритма:

_min_cut = 3

## Вывод

В результате выполнения данной расчётной работы был формализован алгоритм нахождения минимального разреза графа.

## Источники
[Руководство к выполнению расчётной работы](https://drive.google.com/file/d/1bq0WHZEQR-W9iAGYWvGShXRVT5iuzw7b/view)